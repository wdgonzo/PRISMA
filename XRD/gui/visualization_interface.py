#!/usr/bin/env python3
"""
XRD Data Visualization Interface
================================
GUI interface for visualizing XRD data from Zarr files.
Focuses on loading processed data and creating interactive heatmap visualizations.

This interface loads Zarr data files generated by the data_generator.py
and provides interactive controls for visualization parameters.

Author(s): William Gonzalez
Date: October 2025
Version: Beta 0.1
"""

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QPushButton, QVBoxLayout, QHBoxLayout,
    QWidget, QFileDialog, QLineEdit, QComboBox, QCheckBox, QMessageBox, QGridLayout,
    QListWidget, QListWidgetItem, QSplitter, QTextEdit, QGroupBox, QSpinBox
)
from PyQt5 import QtGui, QtCore
from PyQt5.QtGui import QCursor
from PyQt5.QtCore import Qt
import json
import os
import sys
import glob
from datetime import datetime

# Import visualization components
from XRD.visualization import data_visualization
from XRD.core.gsas_processing import XRDDataset, Stages


class VisualizationWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("XRD Data Visualization Interface")
        self.setGeometry(100, 100, 1000, 700)

        # Default visualization parameters
        self.vis_params = {
            "Map_Type": "strain",
            "Mode": "Robust",
            "Color": "icefire",
            "Lower Locked Limit": "0",
            "Upper Locked Limit": "0",
            "save_plot_folder": "",
            "save_csv": False,
            "plot_with_cof": False,
            "cof_data_file": "No file selected",
            "Az Start": "-90",
            "Az End": "90",
            "spacing": "5"
        }

        # Initialize UI
        self.init_ui()
        self.refresh_zarr_files()

    def init_ui(self):
        """Initialize the user interface."""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Create main splitter
        main_splitter = QSplitter(Qt.Horizontal)
        central_widget_layout = QVBoxLayout(central_widget)
        central_widget_layout.addWidget(main_splitter)

        # Left panel - File browser and dataset info
        left_panel = self.create_file_browser_panel()
        main_splitter.addWidget(left_panel)

        # Right panel - Visualization controls
        right_panel = self.create_visualization_panel()
        main_splitter.addWidget(right_panel)

        # Set splitter proportions
        main_splitter.setSizes([400, 600])

    def create_file_browser_panel(self):
        """Create the left panel with file browser and dataset information."""
        panel = QWidget()
        layout = QVBoxLayout(panel)

        # File browser section
        file_group = QGroupBox("Available Zarr Datasets")
        file_layout = QVBoxLayout(file_group)

        # Refresh button
        refresh_btn = QPushButton("üîÑ Refresh")
        refresh_btn.clicked.connect(self.refresh_zarr_files)
        file_layout.addWidget(refresh_btn)

        # File list
        self.zarr_list = QListWidget()
        self.zarr_list.itemClicked.connect(self.on_zarr_selected)
        file_layout.addWidget(self.zarr_list)

        layout.addWidget(file_group)

        # Dataset info section
        info_group = QGroupBox("Dataset Information")
        info_layout = QVBoxLayout(info_group)

        self.info_text = QTextEdit()
        self.info_text.setReadOnly(True)
        self.info_text.setMaximumHeight(200)
        info_layout.addWidget(self.info_text)

        layout.addWidget(info_group)

        return panel

    def create_visualization_panel(self):
        """Create the right panel with visualization controls."""
        panel = QWidget()
        layout = QVBoxLayout(panel)

        # Visualization parameters section
        params_group = QGroupBox("Visualization Parameters")
        params_layout = QGridLayout(params_group)

        # Map type selection
        params_layout.addWidget(QLabel("Map Type:"), 0, 0)
        self.map_type_combo = QComboBox()
        self.map_type_combo.addItems([
            "strain", "d-spacing", "peak_area", "peak_width",
            "gamma_y", "gamma_z", "background"
        ])
        self.map_type_combo.setCurrentText(self.vis_params["Map_Type"])
        params_layout.addWidget(self.map_type_combo, 0, 1)

        # Visualization mode
        params_layout.addWidget(QLabel("Mode:"), 1, 0)
        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Standard", "Robust", "Robust L.L.", "Standard L.L."
        ])
        self.mode_combo.setCurrentText(self.vis_params["Mode"])
        params_layout.addWidget(self.mode_combo, 1, 1)

        # Color map
        params_layout.addWidget(QLabel("Color Map:"), 2, 0)
        self.color_combo = QComboBox()
        self.color_combo.addItems([
            "icefire", "viridis", "plasma", "inferno", "coolwarm", "RdBu_r"
        ])
        self.color_combo.setCurrentText(self.vis_params["Color"])
        params_layout.addWidget(self.color_combo, 2, 1)

        # Locked limits
        params_layout.addWidget(QLabel("Lower Locked Limit:"), 3, 0)
        self.lower_limit_entry = QLineEdit(self.vis_params["Lower Locked Limit"])
        params_layout.addWidget(self.lower_limit_entry, 3, 1)

        params_layout.addWidget(QLabel("Upper Locked Limit:"), 4, 0)
        self.upper_limit_entry = QLineEdit(self.vis_params["Upper Locked Limit"])
        params_layout.addWidget(self.upper_limit_entry, 4, 1)

        # Peak selection
        params_layout.addWidget(QLabel("Peak Selection:"), 5, 0)
        self.peak_combo = QComboBox()
        self.peak_combo.addItems(["All Peaks", "110 Peak", "200 Peak", "211 Peak"])
        params_layout.addWidget(self.peak_combo, 5, 1)

        # Output options
        self.save_csv_check = QCheckBox("Save CSV data")
        self.save_csv_check.setChecked(self.vis_params["save_csv"])
        params_layout.addWidget(self.save_csv_check, 6, 0, 1, 2)

        self.plot_cof_check = QCheckBox("Plot with COF data")
        self.plot_cof_check.setChecked(self.vis_params["plot_with_cof"])
        params_layout.addWidget(self.plot_cof_check, 7, 0, 1, 2)

        layout.addWidget(params_group)

        # Output settings section
        output_group = QGroupBox("Output Settings")
        output_layout = QGridLayout(output_group)

        # Save folder selection
        output_layout.addWidget(QLabel("Save Folder:"), 0, 0)
        self.save_folder_entry = QLineEdit("No folder selected")
        output_layout.addWidget(self.save_folder_entry, 0, 1)

        save_folder_btn = QPushButton("Browse...")
        save_folder_btn.clicked.connect(self.select_save_folder)
        output_layout.addWidget(save_folder_btn, 0, 2)

        # COF file selection
        output_layout.addWidget(QLabel("COF Data File:"), 1, 0)
        self.cof_file_entry = QLineEdit(self.vis_params["cof_data_file"])
        output_layout.addWidget(self.cof_file_entry, 1, 1)

        cof_file_btn = QPushButton("Browse...")
        cof_file_btn.clicked.connect(self.select_cof_file)
        output_layout.addWidget(cof_file_btn, 1, 2)

        layout.addWidget(output_group)

        # Action buttons
        button_layout = QHBoxLayout()

        # Generate visualizations button
        generate_btn = QPushButton("üé® Generate Visualizations")
        generate_btn.setStyleSheet("QPushButton { font-weight: bold; padding: 10px; }")
        generate_btn.clicked.connect(self.generate_visualizations)
        button_layout.addWidget(generate_btn)

        # Preview button
        preview_btn = QPushButton("üëÅ Preview Data")
        preview_btn.clicked.connect(self.preview_data)
        button_layout.addWidget(preview_btn)

        layout.addLayout(button_layout)

        # Status section
        self.status_text = QTextEdit()
        self.status_text.setReadOnly(True)
        self.status_text.setMaximumHeight(150)
        layout.addWidget(QLabel("Status:"))
        layout.addWidget(self.status_text)

        return panel

    def refresh_zarr_files(self):
        """Refresh the list of available Zarr files from Processed_Data structure."""
        self.zarr_list.clear()

        # Look for Processed_Data directories (new structure)
        processed_base = "Processed_Data"
        zarr_base = "Zarr"  # Fallback for old structure

        zarr_datasets = []

        # Check new Processed_Data structure first
        if os.path.exists(processed_base):
            self.log_status("Scanning Processed_Data directory...")
            for date_folder in os.listdir(processed_base):
                date_path = os.path.join(processed_base, date_folder)
                if os.path.isdir(date_path):
                    for dataset_folder in os.listdir(date_path):
                        dataset_path = os.path.join(date_path, dataset_folder)
                        if os.path.isdir(dataset_path):
                            # Check if it contains Zarr files
                            if any(f.endswith('.zarr') for f in os.listdir(dataset_path)):
                                zarr_datasets.append({
                                    'name': dataset_folder,
                                    'path': dataset_path,
                                    'date': date_folder,
                                    'source': 'Processed_Data'
                                })

        # Fallback to old Zarr structure for backward compatibility
        if os.path.exists(zarr_base):
            self.log_status("Scanning legacy Zarr directory...")
            for item in os.listdir(zarr_base):
                item_path = os.path.join(zarr_base, item)
                if os.path.isdir(item_path) and item != "Old_Zarr":
                    zarr_datasets.append({
                        'name': item,
                        'path': item_path,
                        'date': 'Legacy',
                        'source': 'Zarr'
                    })

        if not zarr_datasets:
            self.log_status("No datasets found. Generate data first using batch processor.")
            return

        # Sort by modification time (newest first)
        zarr_datasets.sort(key=lambda x: os.path.getmtime(x['path']), reverse=True)

        # Add items to list with enhanced display
        for dataset in zarr_datasets:
            display_name = f"[{dataset['date']}] {dataset['name']}"
            item = QListWidgetItem(display_name)

            # Store the actual path in the item data
            item.setData(Qt.UserRole, dataset['path'])

            # Add metadata as tooltip
            mod_time = datetime.fromtimestamp(os.path.getmtime(dataset['path']))
            tooltip = f"Dataset: {dataset['name']}\n"
            tooltip += f"Date: {dataset['date']}\n"
            tooltip += f"Source: {dataset['source']}\n"
            tooltip += f"Modified: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            tooltip += f"Path: {dataset['path']}"
            item.setToolTip(tooltip)

            self.zarr_list.addItem(item)

        self.log_status(f"Found {len(zarr_datasets)} datasets ({sum(1 for d in zarr_datasets if d['source'] == 'Processed_Data')} new, {sum(1 for d in zarr_datasets if d['source'] == 'Zarr')} legacy)")

    def on_zarr_selected(self, item):
        """Handle selection of a Zarr dataset."""
        display_name = item.text()
        zarr_path = item.data(Qt.UserRole)  # Get the actual path stored in item data

        try:
            # Load dataset metadata (need to create dummy params for load function)
            from XRD.core.gsas_processing import GSASParams, Stages, PeakParams

            # Create minimal dummy params for loading (load function requires params but doesn't use them)
            dummy_params = GSASParams(
                home_dir="", images_path="", refs_path=None, control_file="", mask_file="",
                intplot_export=False, sample="", setting="", stage=Stages.CONT, notes="",
                exposure="", active_peaks=[], azimuths=(0, 360), frames=(0, -1),
                spacing=5, step=1, pixel_size=(172.0, 172.0), wavelength=0.1726,
                detector_size=(1475, 1679)
            )

            dataset = XRDDataset.load(zarr_path, dummy_params)

            # Display enhanced dataset information
            info = f"Dataset: {display_name}\n"
            info += f"Path: {zarr_path}\n"
            info += f"Sample: {dataset.params.sample if hasattr(dataset, 'params') else 'Unknown'}\n"
            info += f"Setting: {getattr(dataset.params, 'setting', 'Unknown') if hasattr(dataset, 'params') else 'Unknown'}\n"
            info += f"Stage: {dataset.params.stage.name if hasattr(dataset, 'params') else 'Unknown'}\n"
            info += f"Data Shape: {dataset.data.shape}\n"
            info += f"Peaks: {dataset.data.shape[0]} ({['110', '200', '211'][:dataset.data.shape[0]]})\n"
            info += f"Frames: {dataset.data.shape[1]}\n"
            info += f"Azimuths: {dataset.data.shape[2]}\n"
            info += f"Measurements: {dataset.data.shape[3]}\n"
            info += f"Available measurements:\n"
            for i, measurement in enumerate(dataset.col_idx.keys()):
                info += f"  ‚Ä¢ {measurement}\n"

            # Check for reference data
            if hasattr(dataset, 'reference_values') and dataset.reference_values:
                info += f"Reference data: Available for {len(dataset.reference_values)} measurements\n"
            elif hasattr(dataset, 'reference_d') and dataset.reference_d is not None:
                info += f"Reference data: d-spacing only (legacy)\n"
            else:
                info += f"Reference data: Not available\n"

            self.info_text.setText(info)
            self.selected_dataset = dataset
            self.selected_zarr_path = zarr_path

            self.log_status(f"Loaded dataset: {display_name}")

        except Exception as e:
            error_info = f"Error loading dataset\n"
            error_info += f"Path: {zarr_path}\n"
            error_info += f"Error: {str(e)}\n"
            error_info += f"This may be due to incomplete processing or corrupted data."

            self.info_text.setText(error_info)
            self.selected_dataset = None
            self.selected_zarr_path = None
            self.log_status(f"‚ùå Error loading {display_name}: {e}")

    def select_save_folder(self):
        """Select folder for saving visualizations."""
        folder = QFileDialog.getExistingDirectory(self, "Select Save Folder")
        if folder:
            self.save_folder_entry.setText(folder)

    def select_cof_file(self):
        """Select COF data file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select COF Data File", "", "Excel files (*.xlsx *.xls)"
        )
        if file_path:
            self.cof_file_entry.setText(file_path)

    def collect_visualization_params(self):
        """Collect current visualization parameters."""
        params = {
            "Map_Type": self.map_type_combo.currentText(),
            "Mode": self.mode_combo.currentText(),
            "Color": self.color_combo.currentText(),
            "Lower Locked Limit": self.lower_limit_entry.text(),
            "Upper Locked Limit": self.upper_limit_entry.text(),
            "save_plot_folder": self.save_folder_entry.text(),
            "save_csv": self.save_csv_check.isChecked(),
            "plot_with_cof": self.plot_cof_check.isChecked(),
            "cof_data_file": self.cof_file_entry.text(),
            "Az Start": "-90",  # Default range
            "Az End": "90",
            "spacing": "5"
        }

        # Add locked limits as tuple
        try:
            lower = float(params["Lower Locked Limit"])
            upper = float(params["Upper Locked Limit"])
            params["Locked Limits"] = (lower, upper)
        except ValueError:
            params["Locked Limits"] = (0.0, 0.0)

        return params

    def preview_data(self):
        """Preview the selected dataset structure."""
        if not hasattr(self, 'selected_dataset') or self.selected_dataset is None:
            QMessageBox.warning(self, "No Dataset", "Please select a Zarr dataset first.")
            return

        try:
            dataset = self.selected_dataset

            # Create preview window
            preview_text = f"Dataset Preview\n"
            preview_text += f"================\n\n"
            preview_text += f"Sample: {dataset.params.sample}\n"
            preview_text += f"Setting: {dataset.params.setting}\n"
            preview_text += f"Stage: {dataset.params.stage.name}\n"
            preview_text += f"Data Shape: {dataset.data.shape}\n\n"

            preview_text += f"Available Measurements:\n"
            for measurement in dataset.col_idx.keys():
                preview_text += f"  ‚Ä¢ {measurement}\n"

            preview_text += f"\nFrame Information:\n"
            frames = dataset.frame_numbers[0, :10].compute()  # First 10 frames
            preview_text += f"  First 10 frames: {frames}\n"

            preview_text += f"\nAzimuth Information:\n"
            azimuths = dataset.azimuth_angles[0, :10].compute()  # First 10 azimuths
            preview_text += f"  First 10 azimuths: {azimuths}\n"

            # Show in message box
            msg = QMessageBox()
            msg.setWindowTitle("Dataset Preview")
            msg.setText(preview_text)
            msg.exec_()

        except Exception as e:
            QMessageBox.critical(self, "Preview Error", f"Error previewing dataset: {e}")

    def generate_visualizations(self):
        """Generate visualizations for the selected dataset."""
        if not hasattr(self, 'selected_dataset') or self.selected_dataset is None:
            QMessageBox.warning(self, "No Dataset", "Please select a Zarr dataset first.")
            return

        if self.save_folder_entry.text() == "No folder selected":
            QMessageBox.warning(self, "No Save Folder", "Please select a folder to save visualizations.")
            return

        try:
            # Collect parameters
            vis_params = self.collect_visualization_params()

            # Create minimal values dict for visualization
            values = {
                **vis_params,
                "sample": self.selected_dataset.params.sample,
                "stages": [self.selected_dataset.params.stage.name],
                "setting": self.selected_dataset.params.setting
            }

            self.log_status("Generating visualizations...")
            QApplication.processEvents()  # Update UI

            # Generate visualizations using existing system
            peak_selection = self.peak_combo.currentText()

            if peak_selection == "All Peaks":
                peak_indices = [0, 1, 2]  # 110, 200, 211
                peak_millers = [110, 200, 211]
            elif peak_selection == "110 Peak":
                peak_indices = [0]
                peak_millers = [110]
            elif peak_selection == "200 Peak":
                peak_indices = [1]
                peak_millers = [200]
            elif peak_selection == "211 Peak":
                peak_indices = [2]
                peak_millers = [211]

            # Use the existing visualization system
            for peak_idx, peak_miller in zip(peak_indices, peak_millers):
                self.log_status(f"Generating visualization for {peak_miller} peak...")
                QApplication.processEvents()

                # Create graph parameters (simplified version)
                from XRD.visualization.data_visualization import GraphParams, GraphSetting, Location

                # Convert mode to enum
                mode_mapping = {
                    "Robust L.L.": "ROBUST_LL",
                    "Standard L.L.": "STANDARD_LL"
                }
                graph_input = mode_mapping.get(vis_params["Mode"], vis_params["Mode"].upper())
                graph_type = GraphSetting[graph_input]

                graph_params = GraphParams(
                    graph_type=graph_type,
                    locked_lims=vis_params["Locked Limits"],
                    peak_index=peak_idx,
                    peak_miller=peak_miller,
                    label=vis_params["Map_Type"],
                    sample=self.selected_dataset.params.sample,
                    stage=self.selected_dataset.params.stage,
                    in_situ=(self.selected_dataset.params.stage == Stages.CONT),
                    loc=Location.FULL,
                    ranges=(-90, 90)  # Default range
                )

                # Create visualization
                data_visualization.create_visualization(self.selected_dataset, graph_params, values)

            self.log_status("Visualizations generated successfully!")
            QMessageBox.information(self, "Success",
                                  f"Visualizations have been generated and saved to:\n{vis_params['save_plot_folder']}")

        except Exception as e:
            error_msg = f"Error generating visualizations: {e}"
            self.log_status(f"{error_msg}")
            QMessageBox.critical(self, "Visualization Error", error_msg)

    def log_status(self, message):
        """Log a status message."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.status_text.append(f"[{timestamp}] {message}")
        # Auto-scroll to bottom
        cursor = self.status_text.textCursor()
        cursor.movePosition(cursor.End)
        self.status_text.setTextCursor(cursor)


def main():
    """Main entry point for the visualization interface."""
    app = QApplication(sys.argv)
    window = VisualizationWindow()
    window.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()